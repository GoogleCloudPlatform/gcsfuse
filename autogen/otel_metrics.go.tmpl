// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by main.go. DO NOT EDIT.

package {{ .PackageName }}

import (
	"context"
	"errors"
	"fmt"
	"sync/atomic"
	"time"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
)

var (
	meter = otel.Meter("gcsfuse")
{{- range .Metrics }}
{{- if and (eq .Type "int_histogram") .Attributes }}
{{- range .Combinations }}
	{{ .AttrSetVarName }} = metric.WithAttributeSet(attribute.NewSet(
		{{- $first := true -}}
		{{- range $attrName, $attrValue := .Attributes -}}
			{{- if not $first -}}, {{ end -}}
			{{- $attr := index $.AttrMap $attrName -}}
			attribute.{{ $attr.GoType | ToOtelType }}("{{ $attrName }}", {{ if eq $attr.GoType "string" }}"{{ $attrValue }}"{{ else }}{{ $attrValue }}{{ end }})
			{{- $first = false -}}
		{{- end -}}
	))
{{- end }}
{{- end }}
{{- end }}
)

type MetricHandle interface {
{{- range .Metrics }}
	{{- if eq .Type "int_counter" }}
	{{ .GoName }}(inc int64{{- range .Attributes -}}, {{ .GoName }} {{ .GoType }}{{- end -}})
	{{- else if eq .Type "int_histogram" }}
	{{ .GoName }}(ctx context.Context, latency time.Duration{{- range .Attributes -}}, {{ .GoName }} {{ .GoType }}{{- end -}})
	{{- end }}
{{- end }}
}

type otelMetrics struct {
{{- range .Metrics }}
{{- if eq .Type "int_counter" }}
	{{- range .Combinations }}
	{{ .AtomicVarName }} *atomic.Int64
	{{- end }}
{{- else if eq .Type "int_histogram" }}
	{{ toCamelCase .Name }} metric.Int64Histogram
{{- end }}
{{- end }}
}

{{- define "SwitchCase" }}
    {{- $metric := .Metric -}}
    {{- $node := .Node -}}
    switch {{ $node.AttributeGoName }} {
    {{- range $val, $childNode := .Children }}
    case {{ if eq $node.AttributeGoType "string" }}"{{ $val }}"{{ else }}{{ $val }}{{ end }}:
        {{- if $childNode.IsLeaf }}
			{{- if eq $metric.Type "int_counter" }}
            o.{{ $childNode.LeafCombination.AtomicVarName }}.Add(inc)
			{{- else if eq $metric.Type "int_histogram" }}
			o.{{ toCamelCase $metric.Name }}.Record(ctx, latency.{{ $metric.GoUnitConverter }}(), {{ if $childNode.LeafCombination.AttrSetVarName }}{{ $childNode.LeafCombination.AttrSetVarName }}{{ end }})
			{{- end }}
        {{- else }}
            {{- template "SwitchCase" (dict "Metric" $metric "Node" $childNode) -}}
        {{- end }}
    {{- end }}
    }
{{- end }}

{{- range .Metrics }}
{{- if eq .Type "int_counter" }}
func (o *otelMetrics) {{ .GoName }}(inc int64{{- range .Attributes -}}, {{ .GoName }} {{ .GoType }}{{- end -}}) {
    {{- if .Attributes }}
        {{- template "SwitchCase" (dict "Metric" . "Node" .SwitchTree) -}}
    {{- else }}
        o.{{ (.Combinations | first).AtomicVarName }}.Add(inc)
    {{- end }}
}
{{- else if eq .Type "int_histogram" }}
func (o *otelMetrics) {{ .GoName }}(ctx context.Context, latency time.Duration{{- range .Attributes -}}, {{ .GoName }} {{ .GoType }}{{- end -}}) {
    {{- if .Attributes }}
        {{- template "SwitchCase" (dict "Metric" . "Node" .SwitchTree) -}}
    {{- else }}
        o.{{ toCamelCase .Name }}.Record(ctx, latency.{{ .GoUnitConverter }}())
    {{- end }}
}
{{- end }}
{{ end }}

func NewOTelMetrics() (MetricHandle, error) {
{{- range .Metrics }}
{{- if eq .Type "int_counter" }}
	{{- range .Combinations }}
	var {{ .AtomicVarName }} atomic.Int64
	{{- end }}
{{- end }}
{{- end }}

{{- range .Metrics }}
{{- if eq .Type "int_counter" }}
	{{- range .Combinations }}
	{{ .AttrSetVarName }} := metric.WithAttributeSet(attribute.NewSet(
		{{- $first := true -}}
		{{- range $attrName, $attrValue := .Attributes -}}
			{{- if not $first -}}, {{ end -}}
			{{- $attr := index $.AttrMap $attrName -}}
			attribute.{{ $attr.GoType | ToOtelType }}("{{ $attrName }}", {{ if eq $attr.GoType "string" }}"{{ $attrValue }}"{{ else }}{{ $attrValue }}{{ end }})
			{{- $first = false -}}
		{{- end -}}
	))
	{{- end }}
{{- end }}
{{- end }}

{{- $errVars := "" }}
{{- range $i, $metric := .Metrics }}
	{{- if eq .Type "int_counter" }}
	_, err{{ $i }} := meter.Int64ObservableCounter("{{ .Name }}",
		metric.WithDescription("{{ .Description }}"),
		metric.WithUnit("{{ .Unit }}"),
		metric.WithInt64Callback(func(_ context.Context, obsrv metric.Int64Observer) error {
		{{- range .Combinations }}
			obsrv.Observe({{ .AtomicVarName }}.Load(), {{ .AttrSetVarName }})
		{{- end }}
			return nil
		}))
	{{- else if eq .Type "int_histogram" }}
	{{ toCamelCase .Name }}, err{{ $i }} := meter.Int64Histogram("{{ .Name }}",
		metric.WithDescription("{{ .Description }}"),
		metric.WithUnit("{{ .Unit }}"),
		{{- if .Boundaries }}
		metric.WithExplicitBucketBoundaries({{ range $b_idx, $b := .Boundaries }}{{ $b }}{{ if ne $b_idx (sub (len $.Metrics) 1) }}, {{ end }}{{ end }}))
		{{- end -}}
	)
	{{- end }}
	{{- $errVars = printf "%s, err%d" $errVars $i }}
{{- end }}

	if err := errors.Join({{ $errVars | trimPrefix ", " }}); err != nil {
		return nil, fmt.Errorf("failed to create metrics: %w", err)
	}

	return &otelMetrics{
{{- range .Metrics }}
{{- if eq .Type "int_counter" }}
	{{- range .Combinations }}
		{{ .AtomicVarName }}: &{{ .AtomicVarName }},
	{{- end }}
{{- else if eq .Type "int_histogram" }}
	{{ toCamelCase .Name }}: {{ toCamelCase .Name }},
{{- end }}
{{- end }}
	}, nil
}

func (p *ProcessedMetric) Combinations() []MetricCombination {
	return p.Combinations
}