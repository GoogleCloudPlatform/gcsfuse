// A tool to generate otel_metrics_test.go from metrics.yaml.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"log"
	"os"
	"sort"
	"strings"
	"text/template"

	"github.com/iancoleman/strcase"
	"gopkg.in/yaml.v3"
)

// Metric definition from YAML
type Metric struct {
	MetricName  string      `yaml:"metric-name"`
	Description string      `yaml:"description"`
	Unit        string      `yaml:"unit"`
	Type        string      `yaml:"type"`
	Attributes  []Attribute `yaml:"attributes"`
}

// Attribute definition from YAML
type Attribute struct {
	Name   string   `yaml:"attribute-name"`
	Type   string   `yaml:"attribute-type"`
	Values []string `yaml:"values"`
}

// TemplateData holds all information needed to render a test for a single metric.
type TemplateData struct {
	MetricName     string
	MetricFunc     string
	TestName       string
	Type           string
	Unit           string
	HasAttributes  bool
	Attributes     []AttrInfo
	TestCases      []TestCase
	SummedTestCase SummedCase
}

// AttrInfo describes a single attribute for the template.
type AttrInfo struct {
	YAMLName  string // e.g., "cache_hit"
	GoName    string // e.g., "cacheHit"
	OtelType  string // "Bool", "String"
	GoType    string // "bool", "string"
	IsLast    bool
	IsNumeric bool // True for int64, float64, etc.
}

// TestCase represents a single row in a table-driven test.
type TestCase struct {
	Name          string
	Args          string
	ExpectedAttrs string
}

// SummedCase represents the test case for summing metrics.
type SummedCase struct {
	Invocations []Invocation
	Expected    []Expectation
}
type Invocation struct{ Args string }
type Expectation struct {
	ExpectedAttrs string
	Value         int64
}

const fileHeader = `// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// **** DO NOT EDIT - FILE IS AUTO-GENERATED BY //tools/metric-test-generator ****

package common

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/sdk/metric"
	"go.opentelemetry.io/otel/sdk/metric/metricdata"
)

// metricValueMap maps attribute sets to metric values.
type metricValueMap map[string]int64

// metricHistogramMap maps attribute sets to histogram data points.
type metricHistogramMap map[string]metricdata.HistogramDataPoint[int64]

func waitForMetricsProcessing() {
	time.Sleep(time.Millisecond)
}

func setupOTel(ctx context.Context, t *testing.T) (*otelMetrics, *metric.ManualReader) {
	t.Helper()
	reader := metric.NewManualReader()
	provider := metric.NewMeterProvider(metric.WithReader(reader))
	otel.SetMeterProvider(provider)

	m, err := NewOTelMetrics(ctx, 10, 100)
	require.NoError(t, err)
	return m, reader
}

// gatherHistogramMetrics collects all histogram metrics from the reader.
// It returns a map where the key is the metric name, and the value is another map.
// The inner map's key is a string representation of the attributes,
// and the value is the metricdata.HistogramDataPoint.
func gatherHistogramMetrics(ctx context.Context, t *testing.T, rd *metric.ManualReader) map[string]map[string]metricdata.HistogramDataPoint[int64] {
	t.Helper()
	var rm metricdata.ResourceMetrics
	err := rd.Collect(ctx, &rm)
	require.NoError(t, err)

	results := make(map[string]map[string]metricdata.HistogramDataPoint[int64])
	encoder := attribute.DefaultEncoder() // Using default encoder

	for _, sm := range rm.ScopeMetrics {
		for _, m := range sm.Metrics {
			// We are interested in Histogram[int64].
			hist, ok := m.Data.(metricdata.Histogram[int64])
			if !ok {
				continue
			}

			metricMap := make(metricHistogramMap)
			for _, dp := range hist.DataPoints {
				if dp.Count == 0 {
					continue
				}

				metricMap[dp.Attributes.Encoded(encoder)] = dp
			}

			if len(metricMap) > 0 {
				results[m.Name] = metricMap
			}
		}
	}

	return results
}

// gatherNonZeroCounterMetrics collects all non-zero counter metrics from the reader.
// It returns a map where the key is the metric name, and the value is another map.
// The inner map's key is a string representation of the attributes,
// and the value is the metric's value.
func gatherNonZeroCounterMetrics(ctx context.Context, t *testing.T, rd *metric.ManualReader) map[string]map[string]int64 {
	t.Helper()
	var rm metricdata.ResourceMetrics
	err := rd.Collect(ctx, &rm)
	require.NoError(t, err)

	results := make(map[string]map[string]int64)
	encoder := attribute.DefaultEncoder()

	for _, sm := range rm.ScopeMetrics {
		for _, m := range sm.Metrics {
			// We are interested in Sum[int64] which corresponds to int_counter.
			sum, ok := m.Data.(metricdata.Sum[int64])
			if !ok {
				continue
			}

			metricMap := make(metricValueMap)
			for _, dp := range sum.DataPoints {
				if dp.Value == 0 {
					continue
				}

				metricMap[dp.Attributes.Encoded(encoder)] = dp.Value
			}

			if len(metricMap) > 0 {
				results[m.Name] = metricMap
			}
		}
	}

	return results
}
`

const counterTestTemplate = `
func Test{{.TestName}}(t *testing.T) {
	{{if .HasAttributes -}}
	tests := []struct {
		name     string
		f        func(m *otelMetrics)
		expected map[attribute.Set]int64
	}{
		{{- range .TestCases}}
		{
			name: "{{.Name}}",
			f: func(m *otelMetrics) {
				m.{{$.MetricFunc}}({{.Args}})
			},
			expected: map[attribute.Set]int64{
				attribute.NewSet({{.ExpectedAttrs}}): 5,
			},
		},
		{{- end}}
		{
			name: "multiple_attributes_summed",
			f: func(m *otelMetrics) {
				{{- range .SummedTestCase.Invocations}}
				m.{{$.MetricFunc}}({{.Args}})
				{{- end}}
			},
			expected: map[attribute.Set]int64{
				{{- range .SummedTestCase.Expected}}
				attribute.NewSet({{.ExpectedAttrs}}): {{.Value}},
				{{- end}}
			},
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			ctx := context.Background()
			encoder := attribute.DefaultEncoder()
			m, rd := setupOTel(ctx, t)

			tc.f(m)
			waitForMetricsProcessing()

			metrics := gatherNonZeroCounterMetrics(ctx, t, rd)
			metric, ok := metrics["{{.MetricName}}"]
			assert.True(t, ok, "{{.MetricName}} metric not found")
			expectedMap := make(map[string]int64)
			for k, v := range tc.expected {
				expectedMap[k.Encoded(encoder)] = v
			}
			assert.Equal(t, expectedMap, metric)
		})
	}
	{{- else -}}
	ctx := context.Background()
	encoder := attribute.DefaultEncoder()
	m, rd := setupOTel(ctx, t)

	m.{{.MetricFunc}}(1024)
	m.{{.MetricFunc}}(2048)
	waitForMetricsProcessing()

	metrics := gatherNonZeroCounterMetrics(ctx, t, rd)
	metric, ok := metrics["{{.MetricName}}"]
	require.True(t, ok, "{{.MetricName}} metric not found")
	s := attribute.NewSet()
	assert.Equal(t, map[string]int64{s.Encoded(encoder): 3072}, metric)
	{{- end}}
}
`

const histogramTestTemplate = `
func Test{{.TestName}}(t *testing.T) {
	{{if .HasAttributes -}}
	tests := []struct {
		name      string
		latencies []time.Duration
		{{- range .Attributes}}
		{{.GoName}} {{.GoType}}
		{{- end}}
	}{
		{{- range .TestCases}}
		{
			name:      "{{.Name}}",
			latencies: []time.Duration{100 * time.{{if eq $.Unit "us"}}Microsecond{{else}}Millisecond{{end}}, 200 * time.{{if eq $.Unit "us"}}Microsecond{{else}}Millisecond{{end}}},
			{{.Args}}
		},
		{{- end}}
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			ctx := context.Background()
			encoder := attribute.DefaultEncoder()
			m, rd := setupOTel(ctx, t)
			var totalLatency time.Duration

			for _, latency := range tc.latencies {
				m.{{.MetricFunc}}(ctx, latency, {{range $i, $e := .Attributes}}{{if $i}}, {{end}}tc.{{$e.GoName}}{{end}})
				totalLatency += latency
			}
			waitForMetricsProcessing()

			metrics := gatherHistogramMetrics(ctx, t, rd)
			metric, ok := metrics["{{.MetricName}}"]
			require.True(t, ok, "{{.MetricName}} metric not found")
			
			attrs := []attribute.KeyValue{
				{{- range $.Attributes}}
				attribute.{{.OtelType}}("{{.YAMLName}}", tc.{{.GoName}}),
				{{- end}}
			}
			s := attribute.NewSet(attrs...)
			expectedKey := s.Encoded(encoder)
			dp, ok := metric[expectedKey]
			require.True(t, ok, "DataPoint not found for key: %s", expectedKey)
			assert.Equal(t, uint64(len(tc.latencies)), dp.Count)
			assert.Equal(t, totalLatency.{{if eq $.Unit "us"}}Microseconds{{else}}Milliseconds{{end}}(), dp.Sum)
		})
	}
	{{- else -}}
	ctx := context.Background()
	encoder := attribute.DefaultEncoder()
	m, rd := setupOTel(ctx, t)
	latency := 123 * time.{{if eq .Unit "us"}}Microsecond{{else}}Millisecond{{end}}

	m.{{.MetricFunc}}(ctx, latency)
	waitForMetricsProcessing()

	metrics := gatherHistogramMetrics(ctx, t, rd)
	metric, ok := metrics["{{.MetricName}}"]
	require.True(t, ok, "{{.MetricName}} metric not found")
	s := attribute.NewSet()
	expectedKey := s.Encoded(encoder)
	dp, ok := metric[expectedKey]
	require.True(t, ok, "DataPoint not found for key: %s", expectedKey)
	assert.Equal(t, uint64(1), dp.Count)
	assert.Equal(t, latency.{{if eq .Unit "us"}}Microseconds{{else}}Milliseconds{{end}}(), dp.Sum)
	{{- end}}
}
`

// toCamelCase converts a snake_case/kebab-case string to CamelCase.
func toCamelCase(s string) string {
	s = strings.ReplaceAll(s, "/", "_")
	s = strings.ReplaceAll(s, "-", "_")
	return strcase.ToCamel(s)
}

// cartesianProduct computes the cartesian product of the given string lists.
func cartesianProduct(lists [][]string) [][]string {
	if len(lists) == 0 {
		return [][]string{{}}
	}
	result := [][]string{}
	rest := cartesianProduct(lists[1:])
	for _, s := range lists[0] {
		for _, r := range rest {
			result = append(result, append([]string{s}, r...))
		}
	}
	return result
}

func main() {
	inputFile := flag.String("input", "metrics.yaml", "Input YAML file")
	outputFile := flag.String("output", "otel_metrics_test.go", "Output Go test file")
	flag.Parse()

	data, err := os.ReadFile(*inputFile)
	if err != nil {
		log.Fatalf("ReadFile: %v", err)
	}

	var metrics []Metric
	if err := yaml.Unmarshal(data, &metrics); err != nil {
		log.Fatalf("Unmarshal: %v", err)
	}

	var generatedCode bytes.Buffer
	generatedCode.WriteString(fileHeader)

	for _, m := range metrics {
		tmplData := TemplateData{
			MetricName:    m.MetricName,
			MetricFunc:    toCamelCase(m.MetricName),
			TestName:      toCamelCase(m.MetricName),
			Type:          m.Type,
			Unit:          m.Unit,
			HasAttributes: len(m.Attributes) > 0,
		}

		// Sort attributes for deterministic order.
		sort.Slice(m.Attributes, func(i, j int) bool {
			return m.Attributes[i].Name < m.Attributes[j].Name
		})

		var allValues [][]string
		for _, attr := range m.Attributes {
			attrInfo := AttrInfo{
				YAMLName: attr.Name,
				GoName:   strcase.ToLowerCamel(attr.Name),
				GoType:   attr.Type,
				OtelType: strcase.ToCamel(attr.Type),
			}
			tmplData.Attributes = append(tmplData.Attributes, attrInfo)

			if attr.Type == "bool" {
				allValues = append(allValues, []string{"true", "false"})
			} else {
				allValues = append(allValues, attr.Values)
			}
		}

		valueCombinations := cartesianProduct(allValues)

		if tmplData.Type == "int_counter" {
			for _, combo := range valueCombinations {
				var tc TestCase
				var nameParts []string
				var argsParts []string
				var expectedAttrsParts []string

				argsParts = append(argsParts, "5") // sample value

				for i, val := range combo {
					attr := m.Attributes[i]
					nameParts = append(nameParts, fmt.Sprintf("%s_%s", attr.Name, val))

					goVal := val
					if attr.Type == "string" {
						goVal = `"` + val + `"`
					}
					argsParts = append(argsParts, goVal)
					expectedAttrsParts = append(expectedAttrsParts, fmt.Sprintf(`attribute.%s("%s", %s)`, strcase.ToCamel(attr.Type), attr.Name, goVal))
				}
				tc.Name = strings.ReplaceAll(strings.Join(nameParts, "_"), "/", "_")
				tc.Args = strings.Join(argsParts, ", ")
				tc.ExpectedAttrs = strings.Join(expectedAttrsParts, ", ")
				tmplData.TestCases = append(tmplData.TestCases, tc)
			}
			// Create a summed test case
			if len(tmplData.TestCases) > 1 {
				tc1 := tmplData.TestCases[0]
				tc2 := tmplData.TestCases[1]
				tmplData.SummedTestCase.Invocations = append(tmplData.SummedTestCase.Invocations, Invocation{Args: "5, " + strings.SplitN(tc1.Args, ", ", 2)[1]})
				tmplData.SummedTestCase.Invocations = append(tmplData.SummedTestCase.Invocations, Invocation{Args: "2, " + strings.SplitN(tc2.Args, ", ", 2)[1]})
				tmplData.SummedTestCase.Invocations = append(tmplData.SummedTestCase.Invocations, Invocation{Args: "3, " + strings.SplitN(tc1.Args, ", ", 2)[1]})
				tmplData.SummedTestCase.Expected = append(tmplData.SummedTestCase.Expected, Expectation{ExpectedAttrs: tc1.ExpectedAttrs, Value: 8})
				tmplData.SummedTestCase.Expected = append(tmplData.SummedTestCase.Expected, Expectation{ExpectedAttrs: tc2.ExpectedAttrs, Value: 2})
			}

			t, err := template.New("counter").Parse(counterTestTemplate)
			if err != nil {
				log.Fatalf("parsing counter template: %v", err)
			}
			if err := t.Execute(&generatedCode, tmplData); err != nil {
				log.Fatalf("executing counter template: %v", err)
			}
		} else if tmplData.Type == "int_histogram" {
			for _, combo := range valueCombinations {
				var tc TestCase
				var nameParts, argsParts, expectedAttrsParts []string

				for i, val := range combo {
					attr := m.Attributes[i]
					goVal := val
					if attr.Type == "string" {
						goVal = `"` + val + `"`
					}
					nameParts = append(nameParts, fmt.Sprintf("%s_%s", attr.Name, val))
					argsParts = append(argsParts, fmt.Sprintf("%s: %s", strcase.ToLowerCamel(attr.Name), goVal))
					expectedAttrsParts = append(expectedAttrsParts, fmt.Sprintf(`tc.%s`, strcase.ToLowerCamel(attr.Name)))
				}

				tc.Name = strings.ReplaceAll(strings.Join(nameParts, "_"), "/", "_")
				if len(argsParts) > 0 {
					tc.Args = strings.Join(argsParts, ",\n\t\t\t") + ","
				}
				tc.ExpectedAttrs = strings.Join(expectedAttrsParts, ", ")

				tmplData.TestCases = append(tmplData.TestCases, tc)
			}
			t, err := template.New("histogram").Parse(histogramTestTemplate)
			if err != nil {
				log.Fatalf("parsing histogram template: %v", err)
			}
			if err := t.Execute(&generatedCode, tmplData); err != nil {
				log.Fatalf("executing histogram template: %v", err)
			}
		}
	}

	// This assumes the generator is in a sub-directory of the project root.
	// Adjust if necessary.
	if err := os.WriteFile(*outputFile, generatedCode.Bytes(), 0644); err != nil {
		log.Fatalf("writing to file: %v", err)
	}
}
